---
layout: page
status: publish
published: true
title: OBI
author:
  display_name: Augusto
  login: augusto
  email: gutobenn@gmail.com
  url: ''
author_login: augusto
author_email: gutobenn@gmail.com
wordpress_id: 206
wordpress_url: http://olimpiadascientificas.info/?page_id=206
date: '2011-10-11 17:53:04 -0300'
date_gmt: '2011-10-11 20:53:04 -0300'
categories: []
tags: []
comments: []
---
<p><a title="OBI - Olimp&iacute;ada Brasileira de Inform&aacute;tica" href="http:&#47;&#47;olimpiada.ic.unicamp.br&#47;" target="_blank"><img class="size-full wp-image-138 aligncenter" title="OBI" alt="" src="http:&#47;&#47;olimpiadascientificas.com&#47;wp-content&#47;uploads&#47;2011&#47;10&#47;OBI.jpg" width="217" height="211" &#47;><&#47;a></p>
<p><em><strong><a title="OBI" href="http:&#47;&#47;olimpiada.ic.unicamp.br&#47;" target="_blank">Olimp&iacute;ada Brasileira de Inform&aacute;tica (OBI)<&#47;a><&#47;strong><&#47;em>-</p>
<p>Estes textos foram retirados do site da OBI, com pequenas altera&ccedil;&otilde;es. como negritos, it&aacute;licos e sublihados, feitas pelo "Olimp&iacute;adas Cient&iacute;ficas".</p>
<h3>Organiza&ccedil;&atilde;o<&#47;h3><br />
A organiza&ccedil;&atilde;o da OBI est&aacute; a cargo do <a href="http:&#47;&#47;www.dcc.unicamp.br&#47;">Instituto de Computa&ccedil;&atilde;o<&#47;a> da <a href="http:&#47;&#47;www.unicamp.br&#47;">UNICAMP<&#47;a>.</p>
<h3>Modalidades<&#47;h3><br />
A OBI est&aacute; organizada em duas modalidades:</p>
<ul>
<li><strong>Modalidade Inicia&ccedil;&atilde;o:<&#47;strong>
<ul>
<li><strong>N&iacute;vel 1<&#47;strong>, para alunos at&eacute; o&nbsp;<span style="text-decoration: underline;">s&eacute;timo ano<&#47;span>&nbsp;do Ensino Fundamental, e<&#47;li>
<li><strong>N&iacute;vel 2<&#47;strong>, para alunos at&eacute; o&nbsp;<span style="text-decoration: underline;">nono ano<&#47;span> do Ensino Fundamental;<&#47;li><br />
<&#47;ul><br />
<&#47;li></p>
<li><strong>Modalidade Programa&ccedil;&atilde;o:<&#47;strong>
<ul>
<li><strong>N&iacute;vel J&uacute;nior<&#47;strong>, para alunos do <span style="text-decoration: underline;">Ensino Fundamental<&#47;span>,<&#47;li>
<li><strong>N&iacute;vel 1<&#47;strong>, para alunos at&eacute; o <span style="text-decoration: underline;">segundo ano do Ensino M&eacute;dio<&#47;span> e<&#47;li>
<li><strong>N&iacute;vel 2<&#47;strong>, para alunos at&eacute; o <span style="text-decoration: underline;">terceiro ano do Ensino M&eacute;dio<&#47;span>&nbsp;ou que tenham conclu&iacute;do o Ensino M&eacute;dio at&eacute; dezembro do ano anterior ao da competi&ccedil;&atilde;o (mesmo universit&aacute;rio).<&#47;li><br />
<&#47;ul><br />
<&#47;li><br />
<&#47;ul><br />
Em todas as modalidades os alunos competem individualmente. Cada aluno poder&aacute; estar inscrito <span style="text-decoration: underline;"><strong>em apenas uma modalidade.<&#47;strong><&#47;span></p>
<p>&nbsp;</p>
<h3>Modalidade Inicia&ccedil;&atilde;o - N&iacute;vel 1 e N&iacute;vel 2<&#47;h3></p>
<p style="text-align: justify;">Na modalidade Inicia&ccedil;&atilde;o os alunos concorrem resolvendo<em><strong> problemas de l&oacute;gica <&#47;strong><&#47;em>e problemas de computa&ccedil;&atilde;o, sem uso de computador, apenas utilizando l&aacute;pis e papel. O objetivo desta modalidade &eacute; despertar o gosto por problemas de computa&ccedil;&atilde;o e detectar talentos potenciais para programa&ccedil;&atilde;o.<&#47;p><br />
&nbsp;</p>
<h3>Modalidade Programa&ccedil;&atilde;o - N&iacute;vel J&uacute;nior, N&iacute;vel 1 e N&iacute;vel 2<&#47;h3></p>
<p style="text-align: justify;">A prova da modalidade Programa&ccedil;&atilde;o exige<strong><em> conhecimento em programa&ccedil;&atilde;o<&#47;em><&#47;strong>; &eacute; necess&aacute;rio prover computadores para os participantes, na ocasi&atilde;o da prova. A prova &eacute; composta de tarefas de programa&ccedil;&atilde;o com n&iacute;veis variados de dificuldade: h&aacute; tarefas mais f&aacute;ceis, em que um conhecimento m&iacute;nimo de programa&ccedil;&atilde;o &eacute; suficiente, e algumas tarefas mais dif&iacute;ceis, que exigem um conhecimento um pouco mais avan&ccedil;ado de programa&ccedil;&atilde;o, com no&ccedil;&otilde;es de estruturas de dados, em um n&iacute;vel normalmente ensinado em bons col&eacute;gios t&eacute;cnicos, ou no primeiro ano de cursos superiores de computa&ccedil;&atilde;o ou engenharia.<&#47;p><br />
&nbsp;</p>
<h3>Premia&ccedil;&atilde;o<&#47;h3></p>
<p style="text-align: justify;">Todos os participantes receber&atilde;o<strong><em> certificados de participa&ccedil;&atilde;<&#47;em><&#47;strong>o. Os melhores colocados de cada modalidade receber&atilde;o ainda <strong><em>medalhas de ouro, prata e bronze.<&#47;em><&#47;strong><&#47;p></p>
<p style="text-align: justify;">Os melhores colocados das duas modalidades (Inicia&ccedil;&atilde;o e Programa&ccedil;&atilde;o) ser&atilde;o convidados para u<em><strong>ma semana de cursos no Instituto de Computa&ccedil;&atilde;o da UNICAMP<&#47;strong><&#47;em>. Os alunos da modalidade Inicia&ccedil;&atilde;o participar&atilde;o de Cursos de Introdu&ccedil;&atilde;o &agrave; Programa&ccedil;&atilde;o; os alunos da modalidade Programa&ccedil;&atilde;o participar&atilde;o de Cursos de Programa&ccedil;&atilde;o Avan&ccedil;ada. Os cursos ser&atilde;o ministrados no Instituto de Computa&ccedil;&atilde;o da UNICAMP, e acontecer&atilde;o em datas divulgadas oportunamente. Para os alunos da modalidade Programa&ccedil;&atilde;o n&iacute;vel 2, haver&aacute;, durante o Curso de Programa&ccedil;&atilde;o Avan&ccedil;ada, uma sele&ccedil;&atilde;o para escolher os quatro alunos integrantes da equipe brasileira na IOI. A IOI &eacute; um evento j&aacute; tradicional que conta com a participa&ccedil;&atilde;o de mais de 70 pa&iacute;ses;<&#47;p></p>
<h3><&#47;h3></p>
<h3><a href="http:&#47;&#47;olimpiada.ic.unicamp.br&#47;info_geral&#47;programacao&#47;programacao_nivel1&#47;dicas" target="_blank"><strong>Um &oacute;timo texto retirado do site da OBI<&#47;strong><&#47;a><&#47;h3></p>
<table width="100%" border="0" cellpadding="5">
<tbody>
<tr>
<td align="center" valign="top" width="*">
<h3>Como Abordar um Problema de Programa&ccedil;&atilde;o<&#47;h3><br />
<&#47;td><br />
<&#47;tr></p>
<tr>
<td valign="top" width="*"><em>Vin&iacute;cius Jos&eacute; Fortuna<&#47;em><em>(aluno de mestrado do IC-UNICAMP, participante da IOI 99)<&#47;em></p>
<h4>Projete seu programa antes de program&aacute;-lo<&#47;h4><br />
Nunca comece a programar a partir do nada. Deve-se sempre esquematizar alguns pseudo-c&oacute;digos explicando o que o seu programa vai fazer (em um n&iacute;vel mais elevado) antes de come&ccedil;ar a programar. A &uacute;nica exce&ccedil;&atilde;o &eacute; quando se trata de um c&oacute;digo que voc&ecirc; j&aacute; escreveu diversas vezes (p&#47; ex.: encontrar um elemento em um vetor).</p>
<p>Quando se come&ccedil;a a escrever um programa sem ter pensado nele antes, fica dif&iacute;cil visualiz&aacute;-lo como um todo. Criando um rascunho pr&eacute;vio do programa, podem aparecer v&aacute;rias abordagens do problema e as dificuldades ficam mais f&aacute;ceis de serem superadas. Esquematizar o programa ajudar a fixar exatamente o que se deseja e economiza-se bastante tempo em frente ao monitor na tentativa de escrever um programa que cumpra o desejado.</p>
<h4>Escreva um c&oacute;digo leg&iacute;vel<&#47;h4><br />
Escrever um c&oacute;digo leg&iacute;vel &eacute; muito importante para facilitar o entendimento de um programa. At&eacute; para o pr&oacute;prio criador do c&oacute;digo. Em programa claro e auto-explicativo fica mais dif&iacute;cil se perder e torna muito mais f&aacute;cil a depura&ccedil;&atilde;o.</p>
<h4>Comente seu c&oacute;digo enquanto escreve, n&atilde;o depois<&#47;h4><br />
Coment&aacute;rios s&atilde;o ferramentas muito &uacute;teis para tornar o c&oacute;digo mais leg&iacute;vel. &Eacute; interessante comentar tudo que n&atilde;o seja muito claro. N&atilde;o comente algo que seja &oacute;bvio (p&#47; ex<span style="font-family: Arial,Helvetica,Geneva,Swiss,SunSans-Regular; font-size: xx-small;">.: "<span style="font-family: Arial,Helvetica,Geneva,Swiss,SunSans-Regular; font-size: xx-small;">i := 0 { Atribui o valor 0 &agrave; vari&aacute;vel i }" ). Comente algo como<span style="font-family: Arial,Helvetica,Geneva,Swiss,SunSans-Regular; font-size: xx-small;">: "x:= 40 - Lenght(frase)&#47;2 { x recebe a posi&ccedil;&atilde;o para frase ficar centralizada }".<&#47;span><&#47;span><&#47;span></p>
<p>Em programa muito grandes ou complicados, &eacute; interessante criar um cabe&ccedil;alho comentado em cada fun&ccedil;&atilde;o, definindo exatamente o que espera-se que ela fa&ccedil;a, quais suas entradas e quais suas sa&iacute;das. O pseudo-c&oacute;digo rascunhado pode ser muito &uacute;til para isso. Agindo assim, n&atilde;o se precisa ler diversas linhas de c&oacute;digo para saber o que uma fun&ccedil;&atilde;o faz.</p>
<p>&Eacute; recomend&aacute;vel que se escreva os coment&aacute;rios enquanto se escreve o programa, pois &eacute; menos prov&aacute;vel que se escreva alguma coisa &uacute;til ou significativa depois. Escreva enquanto programa e seus coment&aacute;rios ser&atilde;o muito mais completos.</p>
<h4>Utilize margens e indenta&ccedil;&atilde;o apropriadamente<&#47;h4><br />
A cada novo <em>loop<&#47;em>, express&otilde;es condicionais, defini&ccedil;&atilde;o de fun&ccedil;&otilde;es e blocos de comandos, seu c&oacute;digo deve ser indentado um n&iacute;vel mais &agrave; direita (pressione [TAB] ou a barra de espa&ccedil;o algumas vezes). Esteja certo de voltar ao n&iacute;vel de indenta&ccedil;&atilde;o anterior quando terminar o bloco.</p>
<p>Linhas em branco tamb&eacute;m s&atilde;o muito &uacute;teis para aumentar a legibilidade do seu c&oacute;digo. Umas duas linhas entre as defini&ccedil;&otilde;es de fun&ccedil;&otilde;es e procedimentos e uma linha entre a defini&ccedil;&atilde;o de vari&aacute;veis e o c&oacute;digo ir&atilde;o separar claramente cada parte, o que torna a identifica&ccedil;&atilde;o delas mais r&aacute;pida. Isso torna o c&oacute;digo bem mais claro.</p>
<h4>Use nomes sugestivos para vari&aacute;veis, fun&ccedil;&otilde;es e procedimentos<&#47;h4><br />
O c&oacute;digo fica incrivelmente mais dif&iacute;cil de ser depurado quando vari&aacute;veis importantes se chamam p, t, ma1, qq, e assim por diante. Deve-se sempre utilizar nomes sugestivos para as vari&aacute;veis, fun&ccedil;&otilde;es e procedimentos. O nome deve dar id&eacute;ia do que a vari&aacute;vel representa ou o que a fun&ccedil;&atilde;o ou procedimento fazem. Por exemplo, se voc&ecirc; quer armazenar o n&uacute;mero de alunos em uma vari&aacute;vel, pode-se usar um_alunos. Se for uma fun&ccedil;&atilde;o que calcula o sal&aacute;rio m&eacute;dio, pode-se nome&aacute;-la</p>
<h4>Utilize fun&ccedil;&otilde;es e procedimentos curtos e objetivos<&#47;h4><br />
Evite sempre fun&ccedil;&otilde;es&#47;procedimentos grandes que englobem todo tipo de processamento. Separe algoritmos distintos em suas pr&oacute;prias fun&ccedil;&otilde;es&#47;procedimentos. Projete sua grande fun&ccedil;&atilde;o&#47;procedimento em v&aacute;rias pequenas, de forma que seu programa fique mais f&aacute;cil de ler e entender.</p>
<p>Dessa forma, cada parte do seu programa fica bem definida e torna-se muito mais f&aacute;cil escrev&ecirc;-lo, pois pode-se faz&ecirc;-lo passo a passo. Dessa forma, a cada parte que se termina, pode-se verificar se ela est&aacute; correta. Al&eacute;m disso a localiza&ccedil;&atilde;o de um problema no programa tamb&eacute;m fica facilitada, pois ele se restringir&aacute; a um bloco menor de c&oacute;digo.</p>
<h4>Conclus&atilde;o:<&#47;h4><br />
Lembre-se que a maior parte do tempo que se gasta programando &eacute; corrigindo e modificando c&oacute;digo</p>
<p>existente. Relativamente pouco tempo &eacute; realmente utilizado para adicionar coisas novas. Isso significa que voc&ecirc; gastar&aacute; muito tempo lendo o seu c&oacute;digo, ent&atilde;o faz sentido gastar algum tempo aprendendo a escrever um c&oacute;digo leg&iacute;vel. C&oacute;digo leg&iacute;vel &eacute; f&aacute;cil de escrever, f&aacute;cil de depurar e f&aacute;cil de manter. Voc&ecirc; realmente sai ganhando!</p>
<h4>Se estiver confuso na hora da depura&ccedil;&atilde;o<&#47;h4><br />
Se voc&ecirc; estiver confuso ao tentar procurar algum problema no seu programa, tente explic&aacute;-lo para voc&ecirc; mesmo. Dessa forma &eacute; poss&iacute;vel notar inconsist&ecirc;ncias ou fugas ao algoritmo planejado.</p>
<p>Caso isso n&atilde;o resolva, pode-se tentar executar o programa no papel. Isso se aplica tanto a c&oacute;digos que voc&ecirc; escreveu e n&atilde;o est&aacute; mais entendendo como a c&oacute;digos pegos de outros. Funciona da seguinte maneira: Pegue uma folha em branco e liste todas as vari&aacute;veis usadas no programa. Siga linha por linha do c&oacute;digo, escrevendo o valor das vari&aacute;veis enquanto elas mudam, como se voc&ecirc; fosse o computador. Pode-se usar uma calculadora para ajudar nas contas. Anote todas as sa&iacute;das em uma folha &agrave; parte. Ap&oacute;s algumas poucas itera&ccedil;&otilde;es a estrutura b&aacute;sica do algoritmo e sua inten&ccedil;&atilde;o devem ficar claras. Tome cuidado, pois nem sempre o c&oacute;digo funciona do jeito que n&oacute;s pensamos que funciona.</p>
<h3><strong>Guia pr&aacute;tico para resolu&ccedil;&atilde;o de problemas de programa&ccedil;&atilde;o<&#47;strong><&#47;h3></p>
<h4>1) Entender o problema<&#47;h4></p>
<ul>
<li>Esteja certo de que tenha entendido o problema;<&#47;li>
<li>O que &eacute; a entrada?<&#47;li>
<li>O que &eacute; a sa&iacute;da?<&#47;li><br />
<&#47;ul></p>
<h4>2) Resolver o problema &agrave; m&atilde;o<&#47;h4></p>
<ul>
<li>Resolva pequenas inst&acirc;ncias do problema &agrave; m&atilde;o;<&#47;li>
<li>O que acontece?<&#47;li>
<li>Pense em casos variados;<&#47;li>
<li>Pense em como (qual algoritmo) voc&ecirc; utilizou para resolver o problema.<&#47;li><br />
<&#47;ul></p>
<h4>3) Definir o algoritmo<&#47;h4></p>
<ul>
<li>Defina precisamente o algoritmo a ser utilizado<&#47;li>
<li>Rascunhe as etapas do programa<&#47;li><br />
<&#47;ul></p>
<h4>4) Programar<&#47;h4></p>
<ul>
<li>Como escrever o algoritmo na linguagem utilizada?<&#47;li>
<li>Que estrutura de dado utilizar?<sup>1<&#47;sup><&#47;li>
<li>Divida o programa em partes menores (modularizar);<&#47;li>
<li>Escreva um programa de f&aacute;cil leitura;<&#47;li>
<li>Pense nos casos patol&oacute;gicos.<sup>2<&#47;sup><&#47;li><br />
<&#47;ul></p>
<h4>4) Depurar<&#47;h4></p>
<ul>
<li>Explique o programa para si mesmo;<&#47;li>
<li>Por que funciona?<&#47;li>
<li>A leitura de dados est&aacute; sendo feita corretamente?<&#47;li>
<li>Vari&aacute;veis inicializadas?<&#47;li>
<li>Verificar casos patol&oacute;gicos;<&#47;li>
<li>Localizar o erro restringindo os blocos de c&oacute;digos (cercando o erro)<&#47;li>
<li>Comandos e <em>loops<&#47;em> aninhados corretamente?<&#47;li><br />
<&#47;ul></p>
<h4>Observa&ccedil;&otilde;es:<&#47;h4><br />
1) Que estrutura utilizar?</p>
<p>Qual a melhor forma de representar as vari&aacute;veis do problema. Vari&aacute;veis simples? Vetores? Matrizes? Registros? Alguns vetores? Vetores de registro? Registros de vetores? S&atilde;o muitas as estruturas utiliz&aacute;veis. Deve-se escolher uma que seja conveniente e que n&atilde;o venha trazer complica&ccedil;&otilde;es mais adiante.</p>
<p>2) Pense nos casos patol&oacute;gicos</p>
<p>Os casos patol&oacute;gicos ocorrem quando a propriedade que seu programa utiliza n&atilde;o vale para alguns valores. Normalmente s&atilde;o o zero, um, valores iniciais ou finais. Por exemplo, em uma fun&ccedil;&atilde;o que calcula a pot&ecirc;ncia de um n&uacute;mero <span style="text-decoration: underline;">n<&#47;span> pelo expoente <span style="text-decoration: underline;">e<&#47;span>. Para isso pode-se multiplicar o n&uacute;mero <span style="text-decoration: underline;">n<&#47;span> <span style="text-decoration: underline;">e<&#47;span> vezes. Nesse caso pode-se ter problemas quando o valor de <span style="text-decoration: underline;">e<&#47;span> for zero, caso que deve ser tratado especialmente (considerando a resposta padr&atilde;o como 1, por exemplo). Para ilustrar melhor, imagine o caso em que deseja-se verificar se um vetor est&aacute; ordenado em ordem n&atilde;o-decrescente. Para isso basta verificar se v[n]<=v[n+1] para todos os elementos, exceto o &uacute;ltimo, pois para ele essa propriedade n&atilde;o tem sentido. Os casos patol&oacute;gicos s&atilde;o causa de grande parte dos problemas, especialmente quando se trabalha com ponteiros.</p>
<h4>Refer&ecirc;ncias<&#47;h4></p>
<ul>
<li>www.gamedev.net<&#47;li>
<li>Skiena, Steven S. "The Algorithm Design Manual", Telos, 1997<&#47;li><br />
<&#47;ul><br />
<&#47;td><br />
<&#47;tr><br />
<&#47;tbody><br />
<&#47;table><br />
Fonte: <a href="http:&#47;&#47;olimpiada.ic.unicamp.br&#47;info_geral" target="_blank">http:&#47;&#47;olimpiada.ic.unicamp.br&#47;info_geral<&#47;a></p>
<p>&nbsp;</p>
<h3>O que estudar<&#47;h3><br />
N&oacute;s recomendamos : <a href="http:&#47;&#47;www.olimpiadascientificas.com&#47;estudo&#47;informatica&#47;" target="_self">Estudo inform&aacute;tica<&#47;a>, <a href="http:&#47;&#47;www.olimpiadascientificas.com&#47;olimpiadas&#47;internacionais&#47;ioi&#47;" target="_self">IOI<&#47;a>.</p>
